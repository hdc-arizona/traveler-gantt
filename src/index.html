<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wravel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" type="text/css" href="ravel.css" />
  <script src="//d3js.org/d3.v4.min.js"></script>
  <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
  <script src="split.js"></script>
</head>
<body>
  <div id="traditional-div" class="traditional split split-vertical"></div>
  <div id="overview-div" class="overview split split-vertical"></div>
</body>
</html>
  <script type="text/javascript">
  var ravel = {
    get_data_state: false,
    data: null,
    items: null,
    lanes: null,
    first: null,
    coloring_type: 0,
    selected_rect: null,
    ordering: 0,
    order_change: false,
    scroll_y: false,
    all_lanes: false,
    even_change: false,

    clicked: false,
    cursor: {
      "x": 0,
      "y": 0,
      "width": 1
    },

    margin: {
      top: 20,
      right: 20,
      bottom: 10,
      left: 20
    },
    miniHeight: 60,
    scaleHeight: 20,
    colorBarHeight: 30,

    min_time: 0,
    max_time: 1,
    max_step: 0,
    current_span: 1,
    current_k_scale: 1,
    current_y_offset: 0,
    current_x_offset: 0,
    y_k_factor: 1
  };

  // Figure out width and height of Gantt chart from the window size
  ravel.calc_window_sizes = function () {
    ravel.full_mini_height = ravel.miniHeight + ravel.scaleHeight + ravel.margin.top;
    ravel.width = d3.select('#traditional-div').node().offsetWidth - 5;

    ravel.gantt_width = ravel.width - ravel.margin.left - ravel.margin.right;
    ravel.full_height = $(document).height() - $('body').offset().top;
    ravel.traditional_height = d3.select('#traditional-div').node().offsetHeight;

    if (ravel.traditional_height <= 0) {
      ravel.traditional_gantt_height = ravel.full_height - ravel.full_mini_height -
	2 * ravel.margin.top - ravel.margin.bottom -
	ravel.colorBarHeight - ravel.scaleHeight;
    } else {
      ravel.traditional_gantt_height = ravel.traditional_height - 
	2 * ravel.margin.top - ravel.margin.bottom -
	ravel.colorBarHeight - ravel.scaleHeight;
    }

  }; // end ravel.calc_window_sizes


  ravel.resize = function () {
    ravel.mini_scale
      .range([0, ravel.gantt_width]);
    ravel.phys_scale
      .range([0, ravel.gantt_width]);

    ravel.phys_scaleDateAxis.scale(ravel.phys_scale);
    ravel.xAxis.scale(ravel.mini_scale);
    
    ravel.yphys
      .range([0, ravel.traditional_gantt_height]);
    ravel.total_y_scale
      .range([0, ravel.traditional_gantt_height]);
    
    ravel.phys
      .attr('width', ravel.gantt_width)
      .attr('height', ravel.traditional_gantt_height);

    ravel.mini 
      .attr('width', ravel.gantt_width) 
      .attr('height', ravel.miniHeight);

    ravel.traditional_clip
	.attr('width', ravel.gantt_width)
	.attr('height', ravel.traditional_gantt_height); 

    ravel.traditional_lanes_clip
	.attr('width', ravel.gantt_width)
	.attr('height', ravel.traditional_gantt_height);

    ravel.traditional_scale_clip
	.attr('width', ravel.gantt_width)
	.attr('height', ravel.scaleHeight);

    // White backgrounds for the views
    ravel.phys_background
      .attr('width', ravel.gantt_width)
      .attr('height', ravel.traditional_gantt_height);

    ravel.phys_axis
      .attr('transform', 'translate(0,' + ravel.traditional_gantt_height + ')')
      .call(ravel.phys_scaleDateAxis);

    ravel.mini_axis
      .call(ravel.xAxis);

    // Draw a white background for the overview
    ravel.mini_background
      .attr("width", ravel.gantt_width);

    ravel.draw_traditional();
  } // end ravel.resize


  ravel.splitter_change = function () {
    ravel.calc_window_sizes();
    ravel.resize();
  };


  window.onresize = function(event) {
    ravel.calc_window_sizes();
    ravel.resize();
  }


  var init_ravel = function() {
    ravel.calc_window_sizes();
    var overview_per = ( (ravel.full_mini_height + 5) / ravel.full_height) * 100;
    var trad_per = 100 - overview_per;
    Split(['#traditional-div', '#overview-div'], {
      direction: 'vertical',
      sizes: [trad_per, overview_per],
      minSize: [0, 0],
      onDrag: ravel.splitter_change
    });
    ravel.calc_window_sizes();
  
    ravel.typecolor = d3.scaleLinear()
      .domain([1,2])
      .range(["lightblue", "lightblue"]);
    ravel.bordercolor = d3.scaleLinear()
      .domain([1,2])
      .range(["blue", "blue"]);
    ravel.parentcolor = d3.scaleLinear()
      .domain([0, 2])
      .range(['gray', 'lightgray']);
    ravel.mini_scale = d3.scaleLinear()
      .domain([ravel.min_time, ravel.max_time])
      .range([0, ravel.gantt_width])
    ravel.mini_y_scale = d3.scaleLinear()
      .domain([0, 1])
      .range([0, ravel.miniHeight]);
    ravel.phys_scale = d3.scaleLinear()
      .domain([ravel.min_time, ravel.min_time + ravel.current_span])
      .range([0, ravel.gantt_width]);

    ravel.rows = d3.extent(1);
    ravel.show_rows = [0,1];
    ravel.yphys = d3.scaleLinear()
      .domain([ravel.show_rows[0], ravel.show_rows[1]])
      .range([0, ravel.traditional_gantt_height]);
    ravel.total_y_scale = d3.scaleLinear()
      .domain([ravel.rows[0], ravel.rows[1] + 1])
      .range([0, ravel.traditional_gantt_height]);

    ravel.saved_xmain = [0, 0];
    ravel.saved_yphys = ravel.yphys.domain();
    ravel.saved_stepscale = 1;
    ravel.saved_lanescale = 1;

    // See: http://bl.ocks.org/jgbos/9752277
    // See: https://jsfiddle.net/DaWa/dLmp8zk8/2/

    ravel.zoom_function = function () {
      // ignore zoom-by-brush
      if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return;
      if (ravel.init_in_process) return;

      var t = d3.event.transform;
      if (d3.event.sourceEvent.metaKey) {
	console.log('meta key', ravel.yphys.domain(), t);
	//ravel.yphys.domain(t.rescaleY(ravel.total_y_scale).domain());

	// scale bigger = zoom in
	// scale smaller = zoom out
	ravel.y_k_factor = (ravel.show_rows[1] - ravel.show_rows[0] + 1) * ravel.current_k_scale / ravel.lanes.length;
	var old_domain = ravel.yphys.domain();
	var old_x_domain = ravel.phys_scale.domain();
	console.log('k is', t.k, ravel.current_k_scale, ravel.y_k_factor, (ravel.current_k_scale / ravel.y_k_factor));
	if (Math.abs(t.k - ravel.current_k_scale) > 1e-6) {
	    var y_zoom = t.k / ravel.y_k_factor;

	    // Now with y zoom...
	    // Rescale
	    var show_lanes = ravel.lanes.length / y_zoom;

	    // Translate
	    var old_lanes = old_domain[1] - old_domain[0];
	    var lane_offset = (old_lanes - show_lanes) / 2;

	    console.log('y_zoom', y_zoom, 'show_lanes', show_lanes, 'old_lanes', old_lanes, 'lane_offset', lane_offset);
	    console.log('old_domain', ravel.yphys.domain(), 'current_y_offset', ravel.current_y_offset);
	    ravel.current_y_offset += lane_offset;
	    ravel.init_in_process = true;
	    ravel.zoom.scaleTo(ravel.traditional, ravel.current_k_scale);
	    ravel.zoom.translateTo(ravel.traditional, ravel.current_x_offset, old_domain[0] + lane_offset);
	    ravel.yphys.domain([old_domain[0] + lane_offset, old_domain[1] - lane_offset]);
	    ravel.init_in_process = false;
	    console.log('old_domain', ravel.yphys.domain(), 'current_y_offset', ravel.current_y_offset);
	    ravel.current_k_scale = t.k;
	    ravel.current_y_offset += lane_offset * ravel.yphys.range()[1];
	} else {

	    // current_y_offset is the last offset
	    // current_k_scale is the last scale
	    // y is in the range field, the space of the gantt height
	    // Negative means pulling up. Rows should increase.
	    // Positive means pulling down. Rows should decrease.
	    var total_screen_y = ravel.yphys.range()[1];
	    var screen_frac = (t.y - ravel.current_y_offset) / total_screen_y;
	    var row_frac = screen_frac * (old_domain[1] - old_domain[0]);

	    // Clamp to edges
	    if ((old_domain[0] - row_frac) < ravel.total_y_scale.domain()[0]) {
		row_frac = old_domain[0] - ravel.total_y_scale.domain()[0];
		ravel.current_y_offset = t.y - total_screen_y * row_frac / (old_domain[1] - old_domain[0]);
		console.log('y offset clamped', ravel.current_y_offset);
	    }
	    else if ((old_domain[1] - row_frac) > ravel.total_y_scale.domain()[1]) {
		row_frac = old_domain[1] - ravel.total_y_scale.domain()[1];
		ravel.current_y_offset = t.y - total_screen_y * row_frac / (old_domain[1] - old_domain[0]);
		console.log('y offset clamped 2', ravel.current_y_offset);
	    }
	    else {
		ravel.current_y_offset = t.y;
		console.log('y offset is t.y', ravel.current_y_offset);
	    }

	    ravel.yphys.domain([old_domain[0] - row_frac, old_domain[1] - row_frac]);
	    //ravel.init_in_process = true;
	    ravel.zoom.translateTo(ravel.traditional, ravel.current_x_offset, ravel.current_y_offset);
	    //ravel.init_in_process = false;
	}
	 
	ravel.draw_traditional();
      } else {
	console.log('t in x is', t);
	ravel.current_y_offset = t.y;
	ravel.current_x_offset = t.x;
	ravel.current_k_scale = t.k;
	ravel.phys_scale.domain(t.rescaleX(ravel.mini_scale).domain());
	ravel.gantt_brush_group.call(ravel.gantt_brush.move, 
	  ravel.phys_scale.range().map(t.invertX, t));
	  
	ravel.get_data(d3.max([0, Math.round(ravel.phys_scale.domain()[0])]), 
	  Math.round(ravel.phys_scale.domain()[1]));
      }
    }; // End zoom_function();


    ravel.zoom = d3.zoom()
      .scaleExtent([1, Infinity])
      .translateExtent([[0, 0], [ravel.gantt_width, ravel.traditional_gantt_height]])
      .extent([[0, 0], [ravel.gantt_width, ravel.traditional_gantt_height]])
      .on('zoom', ravel.zoom_function);

    ravel.gantt_brush = d3.brushX()
      .extent([[0, 0], [ravel.gantt_width, ravel.miniHeight]])
      .on("brush end", ravel.gantt_brush_function);

    ravel.traditional = d3.select('#traditional-div')
      .append('svg:svg')
      .attr('id', 'traditional')
      .attr('width', '100%')
      .attr('height', '97%') // Hack to get around overhang issue fighting with inline block
      .attr('class', 'traditional')
      .call(ravel.zoom);

    ravel.phys = ravel.traditional.append('g')
      .attr('transform', 'translate(' + ravel.margin.left + ',' + ravel.margin.top + ')')
      .attr('width', ravel.gantt_width)
      .attr('height', ravel.traditional_gantt_height + ravel.scaleHeight)
      .attr('class', 'phys');
    
    ravel.traditional_clip = ravel.phys.append('defs').append('clipPath')
      .attr('id', 'clip')
      .append('rect')
	.attr('width', ravel.gantt_width)
	.attr('height', ravel.traditional_gantt_height); 

    ravel.traditional_lanes_clip = ravel.phys.append('defs').append('clipPath')
      .attr('id', 'lanesclip')
      .append('rect')
	.attr('width', ravel.gantt_width)
	.attr('height', ravel.traditional_gantt_height);

    ravel.traditional_scale_clip = ravel.phys.append('defs').append('clipPath')
      .attr('id', 'scaleclip')
      .append('rect')
        .attr('y', ravel.traditional_gantt_height)
	.attr('width', ravel.gantt_width)
        .attr('height', ravel.scaleHeight);
    
    // White backgrounds for the views
    ravel.phys_background = ravel.phys.append('rect')
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', ravel.gantt_width)
      .attr('height', ravel.traditional_gantt_height)
      .attr('stroke', 0)
      .attr('fill', 'white')
      .attr('class', 'phys_background');

    // draw the items for the main view, use a clip-path for the ones that
    // are slightly outside of our drawing area
    ravel.physLaneLines = ravel.phys.append('g')
      .attr('clip-path', 'url(#lanesclip)');
    ravel.physRects = ravel.phys.append('g')
      .attr('clip-path', 'url(#clip)');
    ravel.physScale = ravel.phys.append('g')
      .attr('clip-path', 'url(#scaleclip)')

    ravel.overview = d3.select('#overview-div')
      .append('svg:svg')
      .attr('id', 'overview')
      .attr('height', ravel.full_mini_height)
      .attr('width', '100%')
      .attr('class', 'overview')

    ravel.mini = ravel.overview.append('g')
      .attr('transform', 'translate(' + ravel.margin.left + ',' + ravel.margin.top + ')')
      .attr('width', ravel.gantt_width) //ravel.miniWidth)
      .attr('height', ravel.miniHeight)
      .attr('class', 'mini')
      .on('click', ravel.handle_click);

    ravel.counter_scale = d3.scaleLinear()
      .interpolate(d3.interpolateLab)
      .domain([1, 50, 100])
      .range(['lightblue', 'khaki', 'firebrick']);
     
    // draw the x axes on the charts
    ravel.phys_scaleDateAxis = d3.axisBottom(ravel.phys_scale);
    ravel.xAxis = d3.axisBottom(ravel.mini_scale);
    
    ravel.phys_layers = [];
    ravel.phys_comm_event_layer = null;
    ravel.phys_comm_message_layer = null;
    
  };  // Ravel vars


  ravel.init_display = function () {
    ravel.min_time = ravel.data.mintime;
    ravel.max_time = ravel.data.maxtime;
    ravel.max_step = 0;
    ravel.current_span = ravel.data.stoptime - ravel.data.starttime;

    if (ravel.data.hasOwnProperty('max_depth')) {
      ravel.parentcolor.domain([0, ravel.data.max_depth]);
    }
    ravel.mini_scale.domain([ravel.min_time, ravel.max_time]);
    ravel.phys_scale.domain([ravel.data.starttime, ravel.data.stoptime]);
    ravel.mini_y_scale.domain([0, d3.max(ravel.data.overview)]);
    ravel.phys_scaleDateAxis.scale(ravel.phys_scale);
    ravel.xAxis.scale(ravel.mini_scale);


    ravel.phys_axis = ravel.physScale.append('g')
      .attr('transform', 'translate(0,' + ravel.traditional_gantt_height + ')')
      .attr('class', 'phys axis date')
      .call(ravel.phys_scaleDateAxis);

    ravel.mini_axis = ravel.mini.append('g')
      .attr('transform', 'translate(0, ' + ravel.miniHeight + ')')
      .attr('class', 'mini axis date')
      .call(ravel.xAxis);

    // Draw a white background for the overview
    ravel.mini_background = ravel.mini.append('rect')
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", ravel.gantt_width)
      .attr("height", ravel.miniHeight)
      .attr("stroke", 0)
      .attr("fill", "white")
      .attr('class', 'mini_background');
    
    ravel.mini_bars = ravel.mini.append('g')
      .attr('class', 'overviewBar');

    ravel.gantt_brush_group = ravel.mini.append('g')
      .attr("class", "ravel brush")
      .call(ravel.gantt_brush)
      .call(ravel.gantt_brush.move, ravel.mini_scale.range());

    ravel.init_in_process = true;
    ravel.zoom.scaleTo(ravel.traditional, (ravel.max_time - ravel.min_time) / ravel.current_span);
    ravel.current_k_scale = (ravel.max_time - ravel.min_time) / ravel.current_span;
    ravel.current_y_offset = 0;
    ravel.zoom.translateTo(ravel.traditional, 0, 0);
    ravel.init_in_process = false;

    ravel.rows = d3.extent(ravel.lanes);
    ravel.total_y_scale.domain([ravel.rows[0], ravel.rows[1] + 1]);
    ravel.show_rows = [ravel.rows[0], d3.min([ravel.rows[1] + 1, 17])];
    ravel.yphys.domain([ravel.show_rows[0], ravel.show_rows[1]]);
    ravel.y_k_factor = (ravel.show_rows[1] - ravel.show_rows[0] + 1) * ravel.current_k_scale / ravel.lanes.length;
    ravel.saved_xmain = [0, 0];
    ravel.saved_yphys = ravel.yphys.domain();
    ravel.saved_stepscale = 1;
    ravel.saved_lanescale = 1;

    for (var layer = 0; layer < ravel.data.max_depth; layer++) {
      ravel.phys_layers[layer] = ravel.physRects.append('g');
    }
    ravel.phys_comm_event_layer = ravel.physRects.append('g');
    ravel.phys_comm_message_layer = ravel.physRects.append('g');

    // Find out text sizes
    ravel.traditional_font_metrics = ravel.get_text_size(ravel.traditional, 'traditional');

    // Skip text for overview as well as rectangles
    
    ravel.update_cursor();

    ravel.draw_traditional();
    ravel.draw_overview();
  };


  // Figure out text size
  ravel.get_text_size = function (svg, font_class) {
    var test_font = svg.selectAll('.test-font')
      .data(['g'])
      .enter()
      .append('text');

    test_font
      .attr('id', 'ravel-test-font')
      .attr('class', font_class)
      .text(d => { return d; })
      .attr('x', -100)
      .attr('y', -100);

    var bbox = document.getElementById('ravel-test-font').getBoundingClientRect();
 
    test_font.remove();

    return {
      width: bbox.width,
      height: bbox.height
    };
  }

  ravel.gantt_brush_function = function () {
    // ignore brush-by-zoom
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return;
    if (ravel.gantt_brush_group === undefined) return;
    
    var s = d3.event.selection || ravel.mini_scale.range();
    ravel.phys_scale.domain(s.map(ravel.mini_scale.invert, ravel.mini_scale));
    ravel.traditional.call(ravel.zoom.transform, d3.zoomIdentity
      .scale(ravel.gantt_width / (s[1] - s[0]))
      .translate(-s[0], 0));
    ravel.get_data(d3.max([0, Math.round(ravel.phys_scale.domain()[0])]), 
      Math.round(ravel.phys_scale.domain()[1]));
  };
   

  ravel.update_cursor = function() {
      // Nothing for now
  };


  ravel.handle_click = function (d, i) {
    return;
    var clicked = d3.mouse(this);
    ravel.cursor.x = clicked[0];
    ravel.cursor.y = clicked[1];

    var minExtent = ravel.phys_scale.domain()[0];
    var maxExtent = ravel.phys_scale.domain()[1];
    var current_range = maxExtent - minExtent; // current zoom
    ravel.phys_scale.domain([ravel.mini_scale.invert(ravel.cursor.x) - current_range/2.0,
      ravel.mini_scale.invert(ravel.cursor.x) + current_range/2.0]);

    // Zero out so these don't get re-applied
    ravel.zoom.translate([0, 0]);
    ravel.zoom.scale([1]);
    
    ravel.update_cursor();
    
    ravel.get_data(ravel.phys_scale.domain()[0], ravel.phys_scale.domain()[1]);
  };


  ravel.get_data = function (start, stop) {
    if (ravel.get_data_state) {  // quickie perf hack
      return;
    }
    ravel.get_data_state = true;
    $.ajax({
      mimeType: 'text/json; charset=x-user-defined',
      url: '/data',
      method: 'POST',
      dataType: 'json',
      data: { 
	"command" : 'time',
	"start" : start,
	"stop" : stop,
	"entity_start" : ravel.data.entity_start,
	"entities" : ravel.data.entities,
	"width" : ravel.gantt_width
      },
      success: function(json) {
	ravel.update(json.traceinfo);
	ravel.get_data_state = false;
      }
    });
  };


  // Change dict (as object) into array for d3
  ravel.object_filter = function (obj, func) {
    var retarray = [];
    for (key in obj) {
	if (obj.hasOwnProperty(key)) {
	    if (func(obj[key])) {
		retarray.push(obj[key]);
	    }
	}
    }
    return retarray;
  };

  // Find min element of a dict
  ravel.object_min = function (obj, func) {
      var ret = null;
      for (key in obj) {
	  if (obj.hasOwnProperty(key)) {
	      if (ret) {
		  if (func(obj[key]) < ret) {
		      ret = func(obj[key]);
		  }
	      } else {
		  ret = func(obj[key])
	      }
	  }
      }
      return ret;
  };

  // Find max object as a dict
  ravel.object_max = function (obj, func) {
      var ret = null;
      for (key in obj) {
	  if (obj.hasOwnProperty(key)) {
	      if (ret) {
		  if (func(obj[key]) > ret) {
		      ret = func(obj[key]);
		  }
	      } else {
		  ret = func(obj[key])
	      }
	  }
      }
      return ret;
  };


  ravel.init = function (json) {
    ravel.data = json;
    ravel.lanes = [];
    for (var i = 0; i < ravel.data.entities; i++) {
      ravel.lanes.push(ravel.data.entity_start + i);
    }
    ravel.init_display();
  };


  ravel.update = function (json) {
    ravel.data = json;
    console.log(ravel.data);
    d3.select('.axis').call(ravel.phys_scaleDateAxis);
    ravel.draw_traditional();
  };


  // We will draw the labels once off screen to find out their size
  // Then we will update them based on their size and put them into the
  // correct place
  ravel.filter_traditional_labels = function (events) {
    var labels = [];
    var multiplier = ravel.traditional_font_metrics.width;

    for (var i = 0; i < events.length; i++) {
      var evt = events[i];
      var visible_width = d3.min([ravel.phys_scale(evt.exit), ravel.gantt_width]) -
	d3.max([ravel.phys_scale(evt.enter), 0]);
      if (visible_width > multiplier * ravel.data.functions[evt.function].length) {
	labels.push(evt);
      }
    }

    return labels;
  }



  ravel.draw_traditional = function () {
    var rects, msgs, labels,
      minExtent = ravel.phys_scale.domain()[0],
      maxExtent = ravel.phys_scale.domain()[1],
      minEntity = ravel.yphys.domain()[0] - 1,
      maxEntity = ravel.yphys.domain()[1];


    // Remove old lane numbers
    d3.select('#laneNum').remove(); 

    // Add new lanes numbers
    var physLanes = ravel.traditional.append('g')
      .attr('id', 'laneNum');

    // Labels for rows
    var physLanesText = physLanes.selectAll('.laneText')
      .data(ravel.lanes.slice(d3.min[minEntity, 0], maxEntity))
      .text(d => { return d; })
      .attr('y', d => { return ravel.margin.top + ravel.yphys(d + 0.5); });

    physLanesText.enter().append('text')
      .text(d => { return d;})
      .attr('x', ravel.margin.left - 15)
      .attr('y', d => { return ravel.margin.top + ravel.yphys(d + 0.5); })
      .attr('dy', '0.5ex')
      .attr('text-anchor', 'start')
      .attr('class', 'laneText'); // TODO: More CSS

    // Lines between rows
    var laneLines = ravel.physLaneLines.selectAll('.laneLines')
      .data(ravel.lanes.slice(d3.min[minEntity, 0], maxEntity))
      .attr('x2', ravel.gantt_width)
      .attr('y1', d => { return Math.round(ravel.yphys(d)) + 0.5; })
      .attr('y2', d => { return Math.round(ravel.yphys(d)) + 0.5; });

    laneLines.enter().append('line')
      .attr('phys_scale', 0)
      .attr('x1', 0) // d => { return ravel.phys_scale(minExtent); })
      .attr('y1', d => { return Math.round(ravel.yphys(d)) + 0.5; })
      .attr('x2', ravel.gantt_width)
      .attr('y2', d => { return Math.round(ravel.yphys(d)) + 0.5; })
      .attr('class', 'laneLines');

    laneLines.exit().remove();


  
    var barHeight = 0.8 * (ravel.yphys(2.0) - ravel.yphys(1.0));

    // Draw the nested parent function bars
    for (var layer = 0; layer < ravel.data.parent_events.length; layer++) {
      // TODO: Base this on a max depth
      var current_depth = ravel.phys_layers[layer];

      rects = current_depth.selectAll('.parent')
	.data(ravel.data.parent_events[layer], d => { return d.id; })
	.attr('x', d => { return d3.max([ravel.phys_scale(d.enter), -10]); })
	.attr('y', d => { return ravel.yphys(d.entity + 0.1); })
	.attr('height', barHeight)
	.attr('width', d => { return d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	  d3.max([ravel.phys_scale(d.enter), -10]); })
	.style('stroke-width', d => { return (d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	  d3.max([ravel.phys_scale(d.enter), -10])) > 3 ? 1 : 0; });

      rects.enter().append('rect')
	.attr('x', d => { return d3.max([ravel.phys_scale(d.enter), -10]); })
	.attr('y', d => { return ravel.yphys(d.entity + 0.1); })
	.attr('height', barHeight)
	.attr('width', d => { return d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	  d3.max([ravel.phys_scale(d.enter), -10]); })
	.style('fill', d => { return ravel.parentcolor(layer); })
	.style('stroke-width', d => { return (d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	  d3.max([ravel.phys_scale(d.enter), -10])) > 3 ? 1 : 0; })
	.attr('class', 'parent')
	.append('svg:title')
	  .text(d => { return ravel.data.functions[d.function] + ", GUID: " + d.guid + ", Parent: " + d.parent_guid; });

      rects.exit().remove();

      if (ravel.traditional_font_metrics.height + 4 < barHeight) {
	ravel.traditional_label_events = ravel.filter_traditional_labels(
	  ravel.data.parent_events[layer]
	);
      } else {
	ravel.traditional_label_events = [];
      }
      labels = current_depth.selectAll('.evtText')
	.data(ravel.traditional_label_events, d => { return d.id; })
	.attr('x', d => { return d3.max([ravel.phys_scale(d.enter), 0]) + 5; })
	.attr('y', d => { return ravel.yphys(d.entity + 0.1) + 2 + ravel.traditional_font_metrics.height; });

      labels.enter().append('text')
	.attr('x', d => { return d3.max([ravel.phys_scale(d.enter), 0]) + 5; })
	.attr('y', d => { return ravel.yphys(d.entity + 0.1) + 2 + ravel.traditional_font_metrics.height; })
	.attr('class', 'ravel evtText')
	.text(d => { return ravel.data.functions[d.function]; });

      labels.exit().remove();

    }

    // Handle the communication calls differently
    var traditional_comm_items = ravel.data.events.filter(d => { return !d.hasOwnProperty("coalesced"); });
    rects = ravel.phys_comm_event_layer.selectAll('.event')
      .data(traditional_comm_items, d => { return d.id; })
      .attr('x', d => { return ravel.phys_scale(d.enter); })
      .attr('y', d => { return ravel.yphys(d.entity + 0.1); })
      .attr('height', barHeight)
      .attr('width', d => { return d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	d3.max([ravel.phys_scale(d.enter), -10]); })
      .style('stroke-width', d => { return (d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	d3.max([ravel.phys_scale(d.enter), -10])) > 3 ? 1 : 0; });

    rects.enter().append('rect')
      .attr('x', d => { return ravel.phys_scale(d.enter); })
      .attr('y', d => { return ravel.yphys(d.entity + 0.1); })
      .attr('height', barHeight)
      .attr('width', d => { return d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	d3.max([ravel.phys_scale(d.enter), -10]); })
      .style('stroke-width', d => { return (d3.min([ravel.phys_scale(d.exit), ravel.gantt_width + 5]) -
	d3.max([ravel.phys_scale(d.enter), -10])) > 3 ? 1 : 0; })
      .attr('class', 'ravel event')
      .append('svg:title')
	.text(d => { return ravel.data.functions[d.function] + ", GUID: " + d.guid + ", Parent: " + d.parent_guid; });

    rects.exit().remove();
      
    // Draw the labels
    if (ravel.traditional_font_metrics.height + 4 < barHeight) {
      ravel.traditional_label_events = ravel.filter_traditional_labels(
        traditional_comm_items
      );
    } else {
      ravel.traditional_label_events = [];
    }
    labels = ravel.phys_comm_event_layer.selectAll('.evtText')
      .data(ravel.traditional_label_events, d => { return d.id; })
      .attr('x', d => { return d3.max([ravel.phys_scale(d.enter), 0]) + 5; })
      .attr('y', d => { return ravel.yphys(d.entity + 0.1) + 2 + ravel.traditional_font_metrics.height; });

    labels.enter().append('text')
      .attr('x', d => { return d3.max([ravel.phys_scale(d.enter), 0]) + 5; })
      .attr('y', d => { return ravel.yphys(d.entity + 0.1) + 2 + ravel.traditional_font_metrics.height; })
      .attr('class', 'ravel evtText')
      .text(d => { return ravel.data.functions[d.function]; });

    labels.exit().remove();


    // Draw the message lines
    var traditional_messages = ravel.data.messages.filter(
	d => { 
	    return d.sendtime >= ravel.data.starttime || d.recvtime <= ravel.data.stoptime; 
	}
    );   
    console.log(traditional_messages.length, "# messages drawn");
    msgs = ravel.phys_comm_message_layer.selectAll('.message')
      .data(traditional_messages, d => { return d.id; })
      .attr('x1', d => { return ravel.phys_scale(d.sendtime); })
      .attr('x2', d => { return ravel.phys_scale(d.recvtime); })
      .attr('y1', d => { return ravel.yphys(d.sender_entity + 0.5); })
      .attr('y2', d => { return ravel.yphys(d.receiver_entity + 0.5); });

    msgs.enter().append('line')
      .attr('class', 'ravel message')
      .attr('x1', d => { return ravel.phys_scale(d.sendtime); })
      .attr('x2', d => { return ravel.phys_scale(d.recvtime); })
      .attr('y1', d => { return ravel.yphys(d.sender_entity + 0.5); })
      .attr('y2', d => { return ravel.yphys(d.receiver_entity + 0.5); });

    msgs.exit().remove();
  };


  // Draw the overview plot.
  ravel.draw_overview = function () {
    var rects;

    rects = ravel.mini_bars.selectAll('.overviewBar')
      .data(ravel.data.overview)
      .attr('x', (d, i) => { return i; })
      .attr('height', d => { return ravel.miniHeight - ravel.mini_y_scale(d); });

    rects.enter().append('rect')
      .attr('x', (d, i) => { return i; })
      .attr('width', 1)
      .attr('y', d => { return ravel.miniHeight - ravel.mini_y_scale(d); })
      .attr('height', d => { return ravel.mini_y_scale(d); })
      .attr('class', 'overviewBar');

    rects.exit().remove();
  };



// Get the initial data
jQuery(function() {

  $(document).ready(function() {
    init_ravel();
    $.ajax({
      mimeType: 'text/json; charset=x-user-defined',
      url: '/data',
      method: 'POST',
      dataType: 'json',
      data: { 
	"command" : 'load', 
	"width" : ravel.gantt_width
      },
      success: function(json) {
	ravel.init(json.traceinfo);
      }
    });
  });

});
</script>

