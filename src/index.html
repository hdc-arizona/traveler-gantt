<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Traveler</title>
  <!-- Task Runtime Analysis and Visualization for Execution Log Exploration and Research -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" type="text/css" href="traveler.css" />
  <link rel="stylesheet" type="text/css" href="arbtooltip.css" />
  <link rel="stylesheet" type="text/css" href="goldenlayout-base.css" />
  <link rel="stylesheet" type="text/css" href="goldenlayout-light-theme.css" />
  <script src="d3.v5.min.js"></script>
  <script src="jquery-1.11.0.min.js"></script>
  <!-- <script src="d3.tip.v0.6.3.js"></script> -->
  <!-- <script src="d3-tip.js"></script> -->
  <script src="arbtooltip.js"></script>
  <!-- <script src="split.js"></script> -->
  <script src="goldenlayout.min.js"></script>
</head>
<body>
</body>
</html>
  <script type="text/javascript">
  var tenum = {
    OFF: "0",
    SINGLE: "1",
    FULL: "2"
  };

  var traveler_gl_config = {
      settings: {
	  showPopoutIcon: false
      },
      content: [{
	type: 'column',
	content: [{
	    type: 'component',
	    componentName: 'Gantt Chart',
	    componentState: { label: 'Gantt' },
	    height: 80,
	    isClosable: false
	},{
	    type: 'component',
	    componentName: 'Utilization',
	    componenentState: { label: 'Utilization' },
	    height: 20,
	    isClosable: false
	}]
    }]
  };

  var travelerLayout = new GoldenLayout(traveler_gl_config);

  var traveler = {
    init_state: false,
    get_data_state: false,
    get_overview_state: false,
    data: null,
    items: null,
    lanes: null,
    first: null,
    coloring_type: 0,
    selected_rect: null,
    ordering: 0,
    order_change: false,
    scroll_y: false,
    all_lanes: false,
    even_change: false,

    traditional_container: null,
    overview_container: null,

    clicked: false,
    cursor: {
      "x": 0,
      "y": 0,
      "width": 1
    },

    margin: {
      top: 20,
      right: 20,
      bottom: 10,
      left: 50
    },
    miniHeight: 60,
    scale_height: 20,
    colorBarHeight: 30,

    min_time: 0,
    max_time: 1,
    max_step: 0,
    current_span: 1,

    focus_task: "0",
    focus_time: "0",
    focus_state: tenum.OFF,
    hover_task: "0",
    hover_id: "0",
    hover_data: null,
    extended_tips: false,

    brush_selection: [0,0]
  };

  // Figure out width and height of Gantt chart from the window size
  traveler.calc_window_sizes = function (elm) {
    traveler.full_mini_height = traveler.miniHeight + traveler.scale_height + traveler.margin.top;
    //console.log(container.getElement());
    //traveler.width = container.width - 5;
    console.log(elm);
    traveler.width = elm.offsetWidth - 5;

    traveler.gantt_width = traveler.width - traveler.margin.left - traveler.margin.right;
    traveler.full_height = $(document).height() - $('body').offset().top;
    //traveler.traditional_height = container.height;
    traveler.traditional_height = elm.parentNode.offsetHeight;
    elm.setAttribute('style', 'height: ' + traveler.traditional_height + 'px;');

    if (traveler.traditional_height <= 0) {
      traveler.traditional_gantt_height = traveler.full_height - traveler.full_mini_height -
	2 * traveler.margin.top - traveler.margin.bottom -
	traveler.colorBarHeight - traveler.scale_height;
    } else {
      traveler.traditional_gantt_height = traveler.traditional_height - 
	2 * traveler.margin.top - traveler.margin.bottom -
	traveler.colorBarHeight - traveler.scale_height;
    }
    console.log(traveler.width, traveler.traditional_height, traveler.full_height);

  }; // end traveler.calc_window_sizes


  traveler.resize = function () {
    var old_brush_selection = d3.brushSelection(d3.select(".brush").node());
    traveler.mini_scale
      .range([0, traveler.gantt_width]);
    traveler.phys_scale
      .range([0, traveler.gantt_width]);

    traveler.phys_x_axis.scale(traveler.phys_scale);
    traveler.xAxis.scale(traveler.mini_scale);
    traveler.traditional
      .attr('width', '100%')
      .attr('height', '100%'); // Hack to get around overhang issue fighting with inline block
    
    traveler.yphys
      .range([0, traveler.traditional_gantt_height]);
    traveler.total_y_scale
      .range([0, traveler.traditional_gantt_height]);
    
    traveler.phys
      .attr('width', traveler.gantt_width)
      .attr('height', traveler.traditional_gantt_height + traveler.scale_height);

    traveler.mini 
      .attr('width', traveler.gantt_width) 
      .attr('height', traveler.miniHeight);

    d3.select('.brush').remove(); 
    traveler.gantt_brush = d3.brushX()
      .extent([[0, 0], [traveler.gantt_width, traveler.miniHeight]])
      .on("brush end", traveler.gantt_brush_function);
    
    traveler.gantt_brush_group = traveler.mini.append('g')
      .attr("class", "traveler brush")
      .call(traveler.gantt_brush)
      .call(traveler.gantt_brush.move, traveler.mini_scale.range());

    //traveler.gantt_brush.extent([[0, 0], [traveler.gantt_width, traveler.miniHeight]])

    traveler.traditional_clip
	.attr('width', traveler.gantt_width)
	.attr('height', traveler.traditional_gantt_height); 

    traveler.traditional_lanes_clip
	.attr('width', traveler.gantt_width)
	.attr('height', traveler.traditional_gantt_height);

    traveler.traditional_scale_clip
	.attr('height', traveler.scale_height)
        .attr('y', traveler.traditional_gantt_height)
	.attr('width', traveler.gantt_width);

    // White backgrounds for the views
    traveler.phys_background
      .attr('width', traveler.gantt_width)
      .attr('height', traveler.traditional_gantt_height); // + traveler.scale_height);

    traveler.phys_axis
      .attr('transform', 'translate(0,' + traveler.traditional_gantt_height + ')')
      .call(traveler.phys_x_axis);

    traveler.mini_axis
      .call(traveler.xAxis);

    // Draw a white background for the overview
    traveler.mini_background
      .attr("width", traveler.gantt_width);
    
    traveler.zoom 
      .translateExtent([[0, 0], [traveler.gantt_width, traveler.traditional_gantt_height]])
      .extent([[0, 0], [traveler.gantt_width, traveler.traditional_gantt_height]]);

    traveler.draw_traditional();
    traveler.get_overview();

    // Move the brush accordingly to the resize
    var gantt_stretch = traveler.gantt_width / traveler.old_gantt_width;
    var new_x_0 = old_brush_selection[0] * gantt_stretch;
    var new_x_1 = old_brush_selection[1] * gantt_stretch;
    traveler.gantt_brush.move(traveler.gantt_brush_group, [new_x_0, new_x_1]); 
  } // end traveler.resize


    window.onresize = function(event) {
	if (!traveler.init_state) return;
	var elm = document.getElementById('traditionalContainer');
	traveler.old_gantt_width = traveler.gantt_width;
	traveler.calc_window_sizes(elm);
	traveler.resize();
    }
  

  var init_traveler_gantt = function(container) {
    var elm = document.getElementById('traditionalContainer');
    traveler.calc_window_sizes(elm);
    traveler.old_gantt_width = traveler.gantt_width;
    traveler.calc_window_sizes(elm);
    //container.setSize(container.width, //container.getElement().node().offsetWidth,
    //	traveler.traditional_gantt_height);

    traveler.ranked_categorical_scale = d3.scaleOrdinal(d3.schemeSet3); // d3.scaleOrdinal()
    //.domain([0, 8])
    //.range(d3.schemeSet3);
    traveler.bordercolor = d3.scaleLinear()
      .domain([1,2])
      .range(["blue", "blue"]);
    traveler.path_back_color = d3.scaleLinear()
      .domain([0, 4])
      .range(["green", "white"]);
    traveler.parentcolor = d3.scaleLinear()
      .domain([0, 2])
      .range(['gray', 'lightgray']);
    traveler.phys_scale = d3.scaleLinear()
      .domain([traveler.min_time, traveler.min_time + traveler.current_span])
      .range([0, traveler.gantt_width]);

    traveler.rows = d3.extent(1);
    traveler.show_rows = [0,1];
    traveler.yphys = d3.scaleLinear()
      .domain([traveler.show_rows[0], traveler.show_rows[1]])
      .range([0, traveler.traditional_gantt_height]);
    traveler.total_y_scale = d3.scaleLinear()
      .domain([traveler.rows[0], traveler.rows[1] + 1])
      .range([0, traveler.traditional_gantt_height]);


    // See: http://bl.ocks.org/jgbos/9752277
    // See: https://jsfiddle.net/DaWa/dLmp8zk8/2/
    traveler.y_zoom_function = function () {
      var t = d3.event.transform;
      if (traveler.init_in_process) return;
      //console.log('call y zoom', t, traveler.yphys.domain(), traveler.yphys.range());
      traveler.yphys.domain(t.rescaleY(traveler.total_y_scale).domain());
      //traveler.yphys = t.rescaleY(traveler.yphys);
      traveler.draw_traditional();
    }

    traveler.zoom_function = function () {
      // ignore zoom-by-brush
      if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return;
      if (traveler.init_in_process) return;

      var t = d3.event.transform;
      //console.log('zoom', t);
      traveler.phys_scale.domain(t.rescaleX(traveler.mini_scale).domain());
      traveler.gantt_brush_group.call(traveler.gantt_brush.move, 
        traveler.phys_scale.range().map(t.invertX, t));
      //console.log('gantt brush call from zoom');
      
      traveler.get_data(d3.max([0, Math.round(traveler.phys_scale.domain()[0])]), 
        Math.round(traveler.phys_scale.domain()[1]));
      traveler.brush_selection = d3.brushSelection(d3.select(".brush").node());
    }; // End zoom_function();


    traveler.zoom = d3.zoom()
      .scaleExtent([1, Infinity])
      .translateExtent([[0, 0], [traveler.gantt_width, traveler.traditional_gantt_height]])
      .extent([[0, 0], [traveler.gantt_width, traveler.traditional_gantt_height]])
      .on('zoom', traveler.zoom_function);

    traveler.zoomY = d3.zoom()
      .scaleExtent([1, Infinity])
      .translateExtent([[0, 0], [traveler.margin.left, traveler.traditional_gantt_height]])
      .extent([[0, 0], [traveler.margin.left, traveler.traditional_gantt_height]])
      .on('zoom', traveler.y_zoom_function);

    traveler.gantt_brush = d3.brushX()
      .extent([[0, 0], [traveler.gantt_width, traveler.miniHeight]])
      .on("brush end", traveler.gantt_brush_function);

    traveler.traditional = d3.select('#traditionalContainer')
      .append('svg:svg')
      .attr('id', 'traditional')
      .attr('width', '100%')
      .attr('height', '100%') // Hack to get around overhang issue fighting with inline block
      .attr('class', 'traditional')
      .call(traveler.zoom);

      /*
    traveler.traditional
      .call(traveler.event_tip)
      .call(traveler.event_tip_south);
      */

    traveler.phys = traveler.traditional.append('g')
      .attr('transform', 'translate(' + traveler.margin.left + ',' + traveler.margin.top + ')')
      .attr('width', traveler.gantt_width)
      .attr('height', traveler.traditional_gantt_height + traveler.scale_height)
      .attr('class', 'phys');
   
    traveler.overlayY = traveler.traditional
      .append('rect')
      .attr('fill', 'white') //'rgb(255, 0, 255, 0.25')
      .attr('width', traveler.margin.left)
      .attr('height', '100%')
      .attr('y', 0)
      .on('wheel', function () { d3.event.stopPropagation(); })
      .call(traveler.zoomY);
    
    traveler.traditional_clip = traveler.phys.append('defs').append('clipPath')
      .attr('id', 'clip')
      .append('rect')
	.attr('width', traveler.gantt_width)
	.attr('height', traveler.traditional_gantt_height); 

    traveler.traditional_lanes_clip = traveler.phys.append('defs').append('clipPath')
      .attr('id', 'lanesclip')
      .append('rect')
	.attr('width', traveler.gantt_width)
	.attr('height', traveler.traditional_gantt_height);

    traveler.traditional_scale_clip = traveler.phys.append('defs').append('clipPath')
      .attr('id', 'scaleclip')
      .append('rect')
        .attr('y', traveler.traditional_gantt_height)
	.attr('width', traveler.gantt_width)
        .attr('height', traveler.scale_height);
    
    // White backgrounds for the views
    traveler.phys_background = traveler.phys.append('rect')
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', traveler.gantt_width)
      .attr('height', traveler.traditional_gantt_height)
      .attr('stroke', 0)
      .attr('fill', 'white')
      .attr('class', 'phys_background');

    // draw the items for the main view, use a clip-path for the ones that
    // are slightly outside of our drawing area
    traveler.physLaneLines = traveler.phys.append('g')
      .attr('clip-path', 'url(#lanesclip)');
    traveler.physRects = traveler.phys.append('g')
      .attr('clip-path', 'url(#clip)');
    traveler.physScale = traveler.phys.append('g')
      .attr('clip-path', 'url(#scaleclip)')

    traveler.counter_scale = d3.scaleLinear()
      .interpolate(d3.interpolateLab)
      .domain([1, 50, 100])
      .range(['lightblue', 'khaki', 'firebrick']);
     
    // draw the x axes on the charts
    traveler.phys_x_axis = d3.axisBottom(traveler.phys_scale);
    
    traveler.phys_layers = [];
    traveler.phys_comm_event_layer = null;
    traveler.phys_comm_message_layer = null;
    
  };  // traveler vars

  var init_traveler_overview = function(container) {
    var elm = document.getElementById('overviewContainer');
    traveler.mini_scale = d3.scaleLinear()
      .domain([traveler.min_time, traveler.max_time])
      .range([0, traveler.gantt_width])
    traveler.mini_y_scale = d3.scaleLinear()
      .domain([0, 1])
      .range([0, traveler.miniHeight]);

    traveler.overview = d3.select('#overviewContainer')
      .append('svg:svg')
      .attr('id', 'overview')
      .attr('height', traveler.full_mini_height)
      .attr('width', '100%')
      .attr('class', 'overview')

    traveler.mini = traveler.overview.append('g')
      .attr('transform', 'translate(' + traveler.margin.left + ',' + traveler.margin.top + ')')
      .attr('width', traveler.gantt_width) //traveler.miniWidth)
      .attr('height', traveler.miniHeight)
      .attr('class', 'mini')
      .on('click', traveler.handle_click);

    traveler.xAxis = d3.axisBottom(traveler.mini_scale);
    
  };  // traveler vars


  traveler.init_display = function () {
    traveler.min_time = traveler.data.mintime;
    traveler.max_time = traveler.data.maxtime;
    traveler.max_step = 0;
    traveler.current_span = traveler.data.stoptime - traveler.data.starttime;

    if (traveler.data.hasOwnProperty('max_depth')) {
      traveler.parentcolor.domain([0, traveler.data.max_depth]);
    }
    traveler.mini_scale.domain([traveler.min_time, traveler.max_time]);
    traveler.phys_scale.domain([traveler.data.starttime, traveler.data.stoptime]);
    traveler.mini_y_scale.domain([0, d3.max(traveler.data.overview)]);
    traveler.phys_x_axis.scale(traveler.phys_scale);
    traveler.xAxis.scale(traveler.mini_scale);


    traveler.phys_axis = traveler.physScale.append('g')
      .attr('transform', 'translate(0,' + traveler.traditional_gantt_height + ')')
      .attr('class', 'phys axis date')
      .call(traveler.phys_x_axis);

    traveler.mini_axis = traveler.mini.append('g')
      .attr('transform', 'translate(0, ' + traveler.miniHeight + ')')
      .attr('class', 'mini axis date')
      .call(traveler.xAxis);

    // Draw a white background for the overview
    traveler.mini_background = traveler.mini.append('rect')
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", traveler.gantt_width)
      .attr("height", traveler.miniHeight)
      .attr("stroke", 0)
      .attr("fill", "white")
      .attr('class', 'mini_background');
    
    traveler.mini_bars = traveler.mini.append('g')
      .attr('class', 'overviewBar');

    traveler.gantt_brush_group = traveler.mini.append('g')
      .attr("class", "traveler brush")
      .call(traveler.gantt_brush)
      .call(traveler.gantt_brush.move, traveler.mini_scale.range());

    traveler.rows = d3.extent(traveler.lanes);
    traveler.total_y_scale.domain([traveler.rows[0], traveler.rows[1] + 1]);
    traveler.show_rows = [traveler.rows[0], d3.min([traveler.rows[1] + 1, 17])];
    traveler.yphys.domain([traveler.show_rows[0], traveler.show_rows[1]]);

    traveler.init_in_process = true;
    traveler.zoom.scaleTo(traveler.traditional, (traveler.max_time - traveler.min_time) / traveler.current_span);
    traveler.zoom.translateTo(traveler.traditional, 0, 0);
    traveler.zoomY.scaleTo(traveler.overlayY, (traveler.rows[1] + 1 - traveler.rows[0]) / 
	(traveler.show_rows[1] - traveler.show_rows[0]));
    traveler.zoomY.translateTo(traveler.overlayY, 0, 0);
    traveler.init_in_process = false;

    for (var layer = 0; layer < traveler.data.max_depth; layer++) {
      traveler.phys_layers[layer] = traveler.physRects.append('g');
    }
    traveler.phys_comm_event_layer = traveler.physRects.append('g');
    traveler.phys_comm_message_layer = traveler.physRects.append('g');

    // Find out text sizes
    traveler.traditional_font_metrics = traveler.get_text_size(traveler.traditional, 'traditional');

    // Skip text for overview as well as rectangles
    
    traveler.update_cursor();

    traveler.draw_traditional();
    traveler.draw_overview();
    traveler.zoom.translateTo(traveler.traditional, 0, 0);
  };


  // Figure out text size
  traveler.get_text_size = function (svg, font_class) {
    var test_font = svg.selectAll('.test-font')
      .data(['g'])
      .enter()
      .append('text');

    test_font
      .attr('id', 'traveler-test-font')
      .attr('class', font_class)
      .text(d => { return d; })
      .attr('x', -100)
      .attr('y', -100);

    var bbox = document.getElementById('traveler-test-font').getBoundingClientRect();
 
    test_font.remove();

    return {
      width: bbox.width,
      height: bbox.height
    };
  }

  traveler.gantt_brush_function = function () {
    // ignore brush-by-zoom
    if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return;
    if (traveler.gantt_brush_group === undefined) return;
  
    //console.log('old sel is ', traveler.brush_selection);
    var s = d3.event.selection || traveler.brush_selection;
    if (s) {
      traveler.phys_scale.domain(s.map(traveler.mini_scale.invert, traveler.mini_scale));
      //console.log('gantt brush fxn domain is', traveler.phys_scale.domain(), traveler.mini_scale.domain());
      traveler.traditional.call(traveler.zoom.transform, d3.zoomIdentity
        .scale(traveler.gantt_width / (s[1] - s[0]))
        .translate(-s[0], 0));
      //console.log('trying to scale traditional', traveler.zoom.transform, s[1], s[0], traveler.gantt_width);
      traveler.get_data(d3.max([0, Math.round(traveler.phys_scale.domain()[0])]), 
        Math.round(traveler.phys_scale.domain()[1]));
    }

    traveler.brush_selection = d3.brushSelection(d3.select(".brush").node());
  };
   

  traveler.update_cursor = function() {
      // Nothing for now
  };


  traveler.handle_click = function (d, i) {
    return;
    var clicked = d3.mouse(this);
    traveler.cursor.x = clicked[0];
    traveler.cursor.y = clicked[1];

    var minExtent = traveler.phys_scale.domain()[0];
    var maxExtent = traveler.phys_scale.domain()[1];
    var current_range = maxExtent - minExtent; // current zoom
    traveler.phys_scale.domain([traveler.mini_scale.invert(traveler.cursor.x) - current_range/2.0,
      traveler.mini_scale.invert(traveler.cursor.x) + current_range/2.0]);

    // Zero out so these don't get re-applied
    traveler.zoom.translate([0, 0]);
    traveler.zoom.scale([1]);
    
    traveler.update_cursor();
    
    traveler.get_data(traveler.phys_scale.domain()[0], traveler.phys_scale.domain()[1]);
  };


  // TODO: change this to ID and then have the GUID work backwards to 
  // find which GUID really creates things.
  traveler.handle_task_click = function (task) {
    console.log('handle task click');
    if (traveler.focus_task === task.guid) {
	if (traveler.focus_state === tenum.FULL) {
	    traveler.focus_task = "0";
	    traveler.focus_time = "0";
	    traveler.focus_state = tenum.OFF;
	} else {
	    traveler.focus_state = tenum.FULL;
	}
    } else {
	traveler.focus_task = task.guid;
	traveler.focus_time = task.enter;
	traveler.focus_state = tenum.SINGLE;
    }
    traveler.draw_traditional();
    
    // Calculate hover ids
    traveler.get_data(traveler.phys_scale.domain()[0], traveler.phys_scale.domain()[1]);
  }

  traveler.handle_task_mouseover = function(task, over) {
    // if the hover hasn't changed, do nothing
    if (over && task.id === traveler.hover_id) return;

    if (over) {
      traveler.hover_id = task.id;
      traveler.hover_task = task.guid;
      traveler.hover_data = task;
      hideTooltip()
      //traveler.event_tip.hide(task);
      //traveler.event_tip_south.hide(task);

    /*
      var tip_height = traveler.extended_tips ? 25 * 5 + 20 : 25 * 1 + 20;
      if (traveler.yphys(task.entity) < tip_height ) {
        traveler.event_tip_south.show(task);
      } else {
        traveler.event_tip.show(task);
      }
      */
      var tipHTML = 
        "<p class='event-tip'>" + traveler.data.functions[task.function].name + "</p>";
      if (traveler.extended_tips) {
	  tipHTML = "<p class='event-tip'>" + traveler.data.functions[task.function].name + "</p>" +
	    "<p class='event-tip'><span class='event-bold'>GUID: </span>" + task.guid + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Parent: </span>" + task.parent_guid + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Enter: </span>" + task.enter + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Exit: </span>" + task.exit + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>ID: </span>" + task.id + "</p>";
      }
      console.log('hover bounding rect', d3.select('#task' + task.id).node().getBoundingClientRect());
      showTooltip({
	content: tipHTML,
	targetBounds: d3.select('#task' + task.id).node().getBoundingClientRect(),
        hideAfterMs: 0
      });

    } else {
      traveler.hover_id = "0";
      traveler.hover_task = "0";
      traveler.hover_data = null;
      hideTooltip();
      //traveler.event_tip_south.hide(task);
      //traveler.event_tip.hide(task);
    }
    traveler.draw_traditional();
    
    // Calculate hover ids;
    //traveler.get_data(traveler.phys_scale.domain()[0], traveler.phys_scale.domain()[1]);
  }

  traveler.get_overview = function () {
    if (traveler.get_overview_state) {  // quickie perf hack
      return;
    }
    traveler.get_overview_state = true;
    //console.log('overview call');
    $.ajax({
      //mimeType: 'text/json; charset=x-user-defined',
      url: 'data', //'/playground/kisaacs/traveler/data',
      method: 'POST',
      dataType: 'json',
      contentType: 'application/json',
      data: JSON.stringify({ 
	"command" : 'overview',
	"width" : traveler.gantt_width
      }),
      success: function(json) {
	traveler.data.overview = json.traceinfo;
	traveler.draw_overview();
	traveler.get_overview_state = false;
      }
    });
  };


  traveler.get_data = function (start, stop) {
    if (traveler.get_data_state) {  // quickie perf hack
      return;
    }
    traveler.get_data_state = true;
    //console.log('data call');
    $.ajax({
      //mimeType: 'text/json; charset=x-user-defined',
      url: 'data', //'/playground/kisaacs/traveler/data',
      method: 'POST',
      dataType: 'json',
      contentType: 'application/json',
      data: JSON.stringify({ 
	"command" : 'time',
	"start" : start.toString(),
	"stop" : stop.toString(),
	"entity_start" : traveler.data.entity_start.toString(),
	"entities" : traveler.data.entities.toString(),
	"width" : traveler.gantt_width,
	"focus_task" : traveler.focus_task.toString(),
	"focus_time" : traveler.focus_time.toString(),
	"focus_type" : traveler.focus_state.toString(),
	"hover_task" : traveler.hover_task.toString()
      }),
      success: function(json) {
	//console.log(json.traceinfo);
	traveler.update(json.traceinfo);
	traveler.get_data_state = false;
      }
    });
  };


  // Change dict (as object) into array for d3
  traveler.object_filter = function (obj, func) {
    var retarray = [];
    for (key in obj) {
	if (obj.hasOwnProperty(key)) {
	    if (func(obj[key])) {
		retarray.push(obj[key]);
	    }
	}
    }
    return retarray;
  };

  // Find min element of a dict
  traveler.object_min = function (obj, func) {
      var ret = null;
      for (key in obj) {
	  if (obj.hasOwnProperty(key)) {
	      if (ret) {
		  if (func(obj[key]) < ret) {
		      ret = func(obj[key]);
		  }
	      } else {
		  ret = func(obj[key])
	      }
	  }
      }
      return ret;
  };

  // Find max object as a dict
  traveler.object_max = function (obj, func) {
      var ret = null;
      for (key in obj) {
	  if (obj.hasOwnProperty(key)) {
	      if (ret) {
		  if (func(obj[key]) > ret) {
		      ret = func(obj[key]);
		  }
	      } else {
		  ret = func(obj[key])
	      }
	  }
      }
      return ret;
  };


  traveler.init = function (json) {
    traveler.data = json;
    traveler.lanes = [];
    for (var i = 0; i < traveler.data.entities; i++) {
      traveler.lanes.push(traveler.data.entity_start + i);
    }
    traveler.init_display();
  };


  traveler.update = function (json) {
    traveler.data = json;
    //console.log(traveler.data);
    d3.select('.axis').call(traveler.phys_x_axis);
    traveler.draw_traditional();
  };


  // We will draw the labels once off screen to find out their size
  // Then we will update them based on their size and put them into the
  // correct place
  traveler.filter_traditional_labels = function (events) {
    var labels = [];
    var multiplier = traveler.traditional_font_metrics.width;

    for (var i = 0; i < events.length; i++) {
      var evt = events[i];
      var visible_width = d3.min([traveler.phys_scale(evt.exit), traveler.gantt_width]) -
	d3.max([traveler.phys_scale(evt.enter), 0]);
      if (visible_width > multiplier * traveler.data.functions[evt.function].name.length) {
	labels.push(evt);
      }
    }
    return labels;
  }


/*
  traveler.event_tip_south = d3.tip()
    .attr('class', 'd3-tip-s')
    .offset(d => {
	var tip_height = traveler.extended_tips ? 25 * 5 + 20 : 25 * 1 + 30;
	return [20 + tip_height, 0];
    })
    .html(d => {
	if (traveler.extended_tips) {
	  return "<p class='event-tip'>" + traveler.data.functions[d.function].name + "</p>" +
	    "<p class='event-tip'><span class='event-bold'>GUID: </span>" + d.guid + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Parent: </span>" + d.parent_guid + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Enter: </span>" + d.enter + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Exit: </span>" + d.exit + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>ID: </span>" + d.id + "</p>"; 
	} else {
	  return "<p class='event-tip'>" + traveler.data.functions[d.function].name + "</p>";
	}
    });

  traveler.event_tip = d3.tip()
    .attr('class', 'd3-tip')
    .offset([-10, 0])
    .html(d => {
	if (traveler.extended_tips) {
	  return "<p class='event-tip'>" + traveler.data.functions[d.function].name + "</p>" +
	    "<p class='event-tip'><span class='event-bold'>GUID: </span>" + d.guid + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Parent: </span>" + d.parent_guid + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Enter: </span>" + d.enter + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>Exit: </span>" + d.exit + "</p>" + 
	    "<p class='event-tip'><span class='event-bold'>ID: </span>" + d.id + "</p>"; 
	} else {
	  return "<p class='event-tip'>" + traveler.data.functions[d.function].name + "</p>";
	}
    });
*/

  traveler.ranked_function_color = function(fxn) {
    var rank = traveler.data.functions[fxn].rank;
    if (rank > 8) {
	return traveler.ranked_categorical_scale(8);
    } else {
	return traveler.ranked_categorical_scale(rank);
    }
  }
	
  traveler.draw_traditional = function () {
    var rects, msgs, labels,
      minExtent = traveler.phys_scale.domain()[0],
      maxExtent = traveler.phys_scale.domain()[1],
      minEntity = traveler.yphys.domain()[0] - 1,
      maxEntity = traveler.yphys.domain()[1];


    // Remove old lane numbers
    d3.select('#laneNum').remove(); 

    // Add new lanes numbers
    var physLanes = traveler.traditional.append('g')
      .attr('id', 'laneNum');

    // Labels for rows
    var physLanesText = physLanes.selectAll('.laneText')
      .data(traveler.lanes.slice(d3.min[minEntity, 0], maxEntity))
      .text(d => { return d; })
      .attr('y', d => { return traveler.margin.top + traveler.yphys(d + 0.5); });

    physLanesText.enter().append('text')
      .text(d => { return d;})
      .attr('x', traveler.margin.left - 15)
      .attr('y', d => { return traveler.margin.top + traveler.yphys(d + 0.5); })
      .attr('dy', '0.5ex')
      .attr('text-anchor', 'start')
      .attr('class', 'laneText'); // TODO: More CSS

    // Lines between rows
    var laneLines = traveler.physLaneLines.selectAll('.laneLines')
      .data(traveler.lanes.slice(d3.min[minEntity, 0], maxEntity))
      .attr('x2', traveler.gantt_width)
      .attr('y1', d => { return Math.round(traveler.yphys(d)) + 0.5; })
      .attr('y2', d => { return Math.round(traveler.yphys(d)) + 0.5; });

    laneLines.enter().append('line')
      .attr('phys_scale', 0)
      .attr('x1', 0) // d => { return traveler.phys_scale(minExtent); })
      .attr('y1', d => { return Math.round(traveler.yphys(d)) + 0.5; })
      .attr('x2', traveler.gantt_width)
      .attr('y2', d => { return Math.round(traveler.yphys(d)) + 0.5; })
      .attr('class', 'laneLines');

    laneLines.exit().remove();


  
    var barHeight = 0.8 * (traveler.yphys(2.0) - traveler.yphys(1.0));

    // Draw the nested parent function bars
    // note hpx does not have depth
    for (var layer = 0; layer < traveler.data.parent_events.length; layer++) {
      // TODO: Base this on a max depth
      var current_depth = traveler.phys_layers[layer];

      rects = current_depth.selectAll('.parent')
	.data(traveler.data.parent_events[layer], d => { return d.id; })
	.attr('x', d => { return d3.max([traveler.phys_scale(d.enter), -10]); })
	.attr('y', d => { return traveler.yphys(d.entity + 0.1); })
	.attr('height', barHeight)
	.attr('width', d => { return d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	  d3.max([traveler.phys_scale(d.enter), -10]); })
	.style('stroke-width', d => { return (d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	  d3.max([traveler.phys_scale(d.enter), -10])) > 3 ? 1 : 0; });

      rects.enter().append('rect')
	.attr('id', d => { return 'task' + d.id; })
	.attr('x', d => { return d3.max([traveler.phys_scale(d.enter), -10]); })
	.attr('y', d => { return traveler.yphys(d.entity + 0.1); })
	.attr('height', barHeight)
	.attr('width', d => { return d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	  d3.max([traveler.phys_scale(d.enter), -10]); })
	.style('fill', d => { return traveler.parentcolor(layer); })
	.style('stroke-width', d => { return (d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	  d3.max([traveler.phys_scale(d.enter), -10])) > 3 ? 1 : 0; })
	.attr('class', 'parent')
        .on('click', d => { return traveler.handle_task_click(d); })
        .on('mouseover', d => { return travel.handle_task_mouseover(d, true); })
        .on('mouseout', d => { return travel.handle_task_mouseover(d, false); });
	/*
	.append('svg:title')
	  .text(d => { return traveler.data.functions[d.function] + ", GUID: " + d.guid + ", Parent: " + d.parent_guid +
		  ", Enter: " + d.enter + ", Exit: " + d.exit + ", ID: " + d.id; });
	*/

      rects.exit().remove();

      if (traveler.traditional_font_metrics.height + 4 < barHeight) {
	traveler.traditional_label_events = traveler.filter_traditional_labels(
	  traveler.data.parent_events[layer]
	);
      } else {
	traveler.traditional_label_events = [];
      }
      labels = current_depth.selectAll('.evtText')
	.data(traveler.traditional_label_events, d => { return d.id; })
	.attr('x', d => { return d3.max([traveler.phys_scale(d.enter), 0]) + 5; })
	.attr('y', d => { return traveler.yphys(d.entity + 0.1) + 2 + traveler.traditional_font_metrics.height; });

      labels.enter().append('text')
	.attr('x', d => { return d3.max([traveler.phys_scale(d.enter), 0]) + 5; })
	.attr('y', d => { return traveler.yphys(d.entity + 0.1) + 2 + traveler.traditional_font_metrics.height; })
	.attr('class', 'traveler evtText')
	.text(d => { return traveler.data.functions[d.function].name; });

      labels.exit().remove();

    }

    // Handle the communication calls differently
    var traditional_comm_items = traveler.data.events.filter(
      d => { 
	return !d.hasOwnProperty("coalesced")
	  && (traveler.phys_scale(d.enter) < traveler.gantt_width)
	  && (traveler.phys_scale(d.exit) > 0);
      }
    );
    rects = traveler.phys_comm_event_layer.selectAll('.event')
      .data(traditional_comm_items, d => { return d.id; })
      //.attr('x', d => { return traveler.phys_scale(d.enter); })
      .attr('x', d => { return d3.max([traveler.phys_scale(d.enter), -10]); })
      .attr('y', d => { return traveler.yphys(d.entity + 0.1); })
      .attr('height', barHeight)
      .attr('width', d => {
	return d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	    d3.max([traveler.phys_scale(d.enter), -10]); 
      })
      //.style('fill', d => { return (d.sibling) ? traveler.path_back_color(d.depth) : 'lightblue'; })
      .style('fill', d => { 
	  return (traveler.hover_task === d.guid)?
	  //return (traveler.data.hover_ids.includes(d.id))?
	      'goldenrod' :
	      (d.sibling) ? 
		traveler.path_back_color(d.depth) : 
		traveler.ranked_function_color(d.function); 
      })
     .style('fill-opacity', d => {
	return (traveler.hover_task !== "0" && traveler.hover_task !== d.guid) ?
	      0.5 : 1;
      }) 
      .style('stroke-width', d => { return (d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	d3.max([traveler.phys_scale(d.enter), -10])) > 3 ? 1 : 0; });

    rects.enter().append('rect')
      //.attr('x', d => { return traveler.phys_scale(d.enter); })
      .attr('id', d => { return 'task' + d.id })
      .attr('x', d => { return d3.max([traveler.phys_scale(d.enter), -10]); })
      .attr('y', d => { return traveler.yphys(d.entity + 0.1); })
      .attr('height', barHeight)
      .attr('width', d => {
	return d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	    d3.max([traveler.phys_scale(d.enter), -10]); 
      })
      .style('stroke-width', d => { return (d3.min([traveler.phys_scale(d.exit), traveler.gantt_width + 5]) -
	d3.max([traveler.phys_scale(d.enter), -10])) > 3 ? 1 : 0; })
      //.style('fill', d => { return (d.sibling) ? traveler.path_back_color(d.depth) : 'lightblue'; })
      .style('fill', d => { 
	  return (traveler.hover_task === d.guid)?
	  //return (traveler.data.hover_ids.includes(d.id))?
	      'goldenrod' :
	      (d.sibling) ? 
		traveler.path_back_color(d.depth) : 
		traveler.ranked_function_color(d.function); 
      })
      .style('fill-opacity', d => {
	return (traveler.hover_task !== "0" && traveler.hover_task !== d.guid) ?
	      0.5 : 1;
      }) 
      .attr('class', 'traveler event')
      .on('click', d => { return traveler.handle_task_click(d); })
      .on('mouseover', d => { return traveler.handle_task_mouseover(d, true); })
      .on('mouseout', d => { return traveler.handle_task_mouseover(d, false); });
      //.append('svg:title')
     //	.text(d => { return traveler.data.functions[d.function] + ", GUID: " + d.guid + ", Parent: " + d.parent_guid +
    //	  ", Enter: " + d.enter + ", Exit: " + d.exit + ", ID: " + d.id; });

    rects.exit().remove();
      
    // Draw the labels
    if (traveler.traditional_font_metrics.height + 4 < barHeight) {
      traveler.traditional_label_events = traveler.filter_traditional_labels(
        traditional_comm_items
      );
    } else {
      traveler.traditional_label_events = [];
    }
    labels = traveler.phys_comm_event_layer.selectAll('.evtText')
      .data(traveler.traditional_label_events, d => { return d.id; })
      .attr('x', d => { return d3.max([traveler.phys_scale(d.enter), 0]) + 5; })
      .attr('y', d => { return traveler.yphys(d.entity + 0.1) + 2 + traveler.traditional_font_metrics.height; });

    labels.enter().append('text')
      .attr('x', d => { return d3.max([traveler.phys_scale(d.enter), 0]) + 5; })
      .attr('y', d => { return traveler.yphys(d.entity + 0.1) + 2 + traveler.traditional_font_metrics.height; })
      .attr('class', 'traveler evtText')
      .text(d => { return traveler.data.functions[d.function].name; });

    labels.exit().remove();


    // Draw the message lines
    var traditional_messages = traveler.data.messages.filter(
	d => { 
	    return d.sendtime >= traveler.data.starttime || d.recvtime <= traveler.data.stoptime; 
	}
    );   
    //console.log(traditional_messages.length, "# messages drawn");
    msgs = traveler.phys_comm_message_layer.selectAll('.message')
      .data(traditional_messages, d => { return d.id; })
      .style('stroke-width', d => { return d.depth + 1; })
      .style('stroke-opacity', d => { return (d.sibling) ? 1 / (d.depth + 2) : '1.0'; })
      .attr('x1', d => { return traveler.phys_scale(d.sendtime); })
      .attr('x2', d => { return traveler.phys_scale(d.recvtime); })
      .attr('y1', d => { return traveler.yphys(d.sender_entity + 0.5); })
      .attr('y2', d => { return traveler.yphys(d.receiver_entity + 0.5); });

    msgs.enter().append('line')
      .attr('class', 'traveler message')
      .style('stroke-width', d => { return d.depth + 1; })
      .style('stroke-opacity', d => { return (d.sibling) ? 1 / (d.depth + 2) : '1.0'; })
      .attr('x1', d => { return traveler.phys_scale(d.sendtime); })
      .attr('x2', d => { return traveler.phys_scale(d.recvtime); })
      .attr('y1', d => { return traveler.yphys(d.sender_entity + 0.5); })
      .attr('y2', d => { return traveler.yphys(d.receiver_entity + 0.5); });

    msgs.exit().remove();
  };


  // Draw the overview plot.
  traveler.draw_overview = function () {
    //console.log(traveler.data.overview);
    var rects;
    traveler.mini_y_scale.domain([0, 1]);
    //traveler.mini_y_scale.domain([0, d3.max(traveler.data.overview)]);

    rects = traveler.mini_bars.selectAll('.overviewBar')
      .data(traveler.data.overview)
      .attr('fill', 'black')
      .attr('x', (d, i) => { return i; })
      .attr('y', d => { return traveler.miniHeight - traveler.mini_y_scale(d); })
      .attr('height', d => { return traveler.mini_y_scale(d); });

    rects.enter().append('rect')
      .attr('x', (d, i) => { return i; })
      .attr('width', 1)
      .attr('y', d => { return traveler.miniHeight - traveler.mini_y_scale(d); })
      .attr('height', d => { return traveler.mini_y_scale(d); })
      .attr('fill', 'blue')
      .attr('class', 'overviewBar');

    rects.exit().remove();
  };


travelerLayout.registerComponent('Gantt Chart', 
    function(container, componentState) {
	container.getElement().html('<div id="traditionalContainer" height="100%" class="travelerContainer"></div>');
	console.log('set container gantt', container);
	traveler.traditonal_container = container;
	container.on( 'resize', function(){
	    $(window).trigger( 'resize' );
	});
    }
);


travelerLayout.registerComponent('Utilization', 
    function(container, componentState) {
	container.getElement().html('<div id="overviewContainer" class="travelerContainer"></div>');
	console.log('set container overview');
	traveler.overview_container = container;
    }
);

travelerLayout.init();
// <div id="tooltip" class="gl_keep" style="display:none"></div>

console.log('init layout');

// Get the initial data
jQuery(function() {

  $(document).ready(function() {
    //init_traveler_gantt();
    console.log('first ajax call', traveler.traditional_container);
    init_traveler_gantt(traveler.traditional_container);
    init_traveler_overview(traveler.overview_container);
    var body = document.getElementsByTagName('body')[0];
    var tipNode = document.createElement('div');
    tipNode.setAttribute('id', 'tooltip');
    tipNode.setAttribute('class', 'gl_keep');
    tipNode.setAttribute('style', 'display:none');
    body.appendChild(tipNode);
    traveler.init_state = true;
    $.ajax({
      //mimeType: 'text/json; charset=x-user-defined',
      url: 'data', //'playground/kisaacs/traveler/data',
      method: 'POST',
      dataType: 'json',
      contentType: 'application/json',
      data: JSON.stringify({ 
	"command" : 'load', 
	"width" : traveler.gantt_width
      }),
      success: function(json) {
	console.log('extended tips is', json.tips);
	traveler.extended_tips = json.tips;
	traveler.init(json.traceinfo);
      }
    });
  });

});
</script>

